#include "engine.hpp"

std::optional<ChessMove> UCIAdapter::best_move(const FEN& fen) {
    /// go startpos moves {move1} {move2} ... {moveN} -> from the std::vector<std::string> move_strings_ member variable
    return std::nullopt;
}

bool UCIAdapter::is_move_legal(const FEN& fen) {
    /// is_move_legal moves {move1} {move2} ... {moveN} fen {fen}
    /// - assume startpos, then make all the moves
    /// - from that position, do gen_moves and for each generated move, check if legal and get the FEN from the board
    ///   - there is not algorithm for constructing a FEN from the Board class, so I need to implement that
    /// - see whether or not there is a correspondence between the FENs generated by the algorithm and the FEN passed in
    /// pass back a ChessMove or something (e2e4) if the legal move exists, push this onto the move_strings_ member var
    return false;
}

void UCIEngineBuilder::reset() {
    uci_engine_ = std::make_unique<UCIAdapter>();
}

void UCIEngineBuilder::startup_engine() {
    if (!config_.IsDefined()) {
        return; // "Engine" tag not in YAML
    }

    if (config_["tt_size"].IsDefined()) {
        uci_engine_->set_tt_size(config_["tt_size"].as<int>());
    }

    if (config_["threads"].IsDefined()) {
        uci_engine_->set_threads(config_["threads"].as<int>());
    }
}

std::unique_ptr<EngineInterface> UCIEngineBuilder::get_product() {
    return std::move(uci_engine_);
}